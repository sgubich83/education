{
  "common.appName": "Приложение Сергея Губича",
  "common.header": "Приветствую всех в моем тестовом приложении. Технологии развиваются и нужно больше практики чтобы прочувствовать удовольствие от программирывания. Никаких красот не обещаю, основной упор будет сделан на функциональность. Планирую оставлять свои комментарии по каждой из технологий по которым буду повышать свой уровень знаний:",
  "common.work1": "Редакс сага",
  "common.work2": "Файбер",
  "common.work3": "Порталы",
  "common.work4": "Тайпскрипт",
  "common.work5": "Нода для фэйковых апи",
  "common.work6": "Будет добавляться что нибудь еще в процессе",
  "common.description1": "Редакс сага - специфическая но интересная вещь. Начну издалека - Взаимодействие с API довольно частое требование в приложениях.Однако, использование только Redux не дает нам достаточно гибкости. Ядро Redux это контейнер состояния (state container), который поддерживает только синхронные потоки данных. На каждое действие, в хранилище (store) посылается объект, описывающий что произошло, затем вызывается редюсер (reducer) и состояние (state) сразу обновляется. Но в случае асинхронного вызова, вам необходимо сначала дождаться ответа и затем уже, если не было ошибок, обновить состояние. А что если у вашего приложения есть некая сложная логика/workflow? Для этого Redux использует промежуточные слои (middlewares). Промежуточный слой это кусок кода, который выполняется после отправки действия, но перед вызовом редюсера.\nПромежуточные слои могут соединяться в цепочку вызовов для различной обработки действия (action), но на выходе обязательно должен быть простой объект (действие). Redux-thunk является стандартным путем выполнения асинхронных операций в Redux. Redux-thunk позволяет генератору действия (action creator) отправлять функцию в дополнении к объекту, конвертируя таким образом генератор действия в преобразователь. Преимуществом использования redux-thunk является то, что компонент не знает, что выполняется асинхронное действие.\n\nТ.к. промежуточный слой автоматически передает функцию dispatch в функцию, которую возвращает генератор действий, то снаружи, для компонента, нет никакой разницы в вызове синхронных и асинхронных действий (и компонентам больше не нужно об этом беспокоиться). Таким образом, с помощью механизма промежуточных слоев, мы добавили неявный слой (a layer of indirection), который дал нам больше гибкости. А теперь о сагах - Redux-saga это библиотека нацеленная делать сайд-эффекты проще и лучше путем работы с сагами. Саги это дизайн паттерн, который пришел из мира распределенных транзакций, где сага управляет процессами, которые необходимо выполнять транзакционным способом, сохраняя состояние выполнения и компенсируя неудачные процессы. В контексте Redux, сага реализована как промежуточный слой (мы не можем использовать редюсеры потому что они должны быть чистыми функциями), который координирует и побуждает асинхронные действия (сайд-эффекты). Redux-saga делает это с помощью ES6 генераторов. Генераторы (Generators) это функции которые могут быть остановлены и продолжены, вместо выполнения всех выражений в один проход.\n\nКогда вы вызываете функцию-генератор, она возвращает объект-итератор. И с каждым вызовом метода итератора next() тело функции-генератора будет выполняться до следующего yield выражения и затем останавливаться. Если говорить в общем, мы имеем сагу чья работа это следить за отправленными действиями (dispatched actions). Для координирования логики, которую мы хотим реализовать внутри саги, мы можем использовать вспомогательную функцию takeEvery для создания новой саги для выполнения операции. Если есть несколько запросов, takeEvery стартует несколько экземпляров саги-рабочего (worker saga). Иными словами реализует конкурентность(concurrency) для вас. Надо отметить, что сага-наблюдатель (watcher saga) является другим неявным слоем (layer of indirection), который дает больше гибкости для реализации сложной логики (но это может быть лишним для простых приложений). Вместо вызова асинхронного реквеста напрямую, метод call вернет только объект описывающий эту операцию и redux-saga сможет позаботиться о вызове и возвращении результатов в функцию-генератор. Работая с Эффектами, redux-saga делает саги скорее Декларативными, чем Императивными. Декларативное программирование это стиль программирования, который пытается минимизировать или устранить сайд-эффекты, описанием что программа должна делать, вместо описания как она должна это делать. В общем - нужно больше поработать с сагами - пока мне кажется это сложноватым  - наверное потому что я все еще думаю Имперетивно",
  "common.description2": "Файбер - еще не решил как и куда буду добавлять в проект",
  "common.description3": "Порталы - крутая штука. Вот сейчас как раз эта подсказка и сделана с помощью портала. Из документации следует что это способ визуализации элемента в узле DOM, который существует вне иерархии DOM родительского компонента. Т.е. элемент находится где-то в DOM дереве, которое находится за пределами обычного дерева компонентов React, но React всё еще контролирует этот элемент. Обычно это нужно, чтобы дочерний компонент визуально «выходил» из своего контейнера. Например, диалоги, всплывающие подсказки.",
  "common.description4": "Тайпскрипт - использую везде в проекте но иногда выдает ошибки и не всегда понятные описания. Поэтому в некоторых местах добавляю @ts-ignore. С этими проблемами буду разбираться в процессе разработки",
  "common.description5": "Нода для фэйковых апи - пока что использую какое то бесплатное апи но буду добавлять свое апи",
  "common.description6": "Будет добавляться что нибудь еще в процессе",
  "common.required": "Обязательное",
  "common.hint": "Подсказка",
  "common.credentials": "Реквизиты для входа:",
  "common.lazy.button": "или кнопка для ленивых",
  "common.not.found": "Пользователь не найден",
  "common.progress": "В процессе",

  "login.company": "Компания",
  "login.user": "Пользователь",
  "login.password": "Пароль",
  "login.signIn": "Войти",

  "navigation.dashboard": "Ресурсы",
  "navigation.users": "Пользователи",
  "navigation.logout": "Выйти",

  "users.id": "АйДи",
  "users.firstName": "Имя",
  "users.surname": "Фамилия",
  "users.email": "Емаил",
  "users.support": "Поддержка"
}
